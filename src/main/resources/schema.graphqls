schema {
  query: QueryType
  mutation: MutationType
}

type QueryType {
  monthlyPayments(month: YearMonth!): [MonthlySubscription]
  member(id: ID!): Member
  claim(id: ID!): Claim
  paymentSchedule(status: ChargeStatus!): [SchedulerState]
  ticket(id: ID!): Ticket
  getFullTicketHistory(id: ID!): TicketHistory
  tickets(resolved: Boolean): [Ticket!]!
  me: String
  switchableSwitcherEmails: [SwitchableSwitcherEmail!]!
  messageHistory(memberId: ID!): [ChatMessage!]!
  questionGroups: [QuestionGroup!]!
  itemCategories(kind: ItemCategoryKind!, parentId: ID): [ItemCategory!]!
  claimItems(claimId: ID!): [ClaimItem!]!
  findPartnerCampaigns(input: CampaignFilter!): [VoucherCampaign!]!
  getPartnerCampaignOwners: [CampaignOwnerPartner!]!
  dashboardNumbers: DashboardNumbers
  getClaimItemValuation(request: GetValuationInput): ClaimItemValuation!
  canValuateClaimItem(typeOfContract: TypeOfContract!, itemFamilyId: String!, itemTypeId: ID): CanValuateClaimItem
}

type DashboardNumbers {
  numberOfClaims: Int!
  numberOfQuestions: Int!
}

type MutationType {
  chargeMember(id: ID!, amount: MonetaryAmount!): Member
  addAccountEntryToMember(
    memberId: ID!
    accountEntry: AccountEntryInput!
  ): Member!
  approveMemberCharge(approvals: [MemberChargeApproval!]!): Boolean
  createPaymentCompletionLink(memberId: ID!): PaymentCompletionResponse!
  updateClaimState(id: ID!, state: ClaimState!): Claim
  createClaim(memberId: ID!, date: LocalDateTime!, source: ClaimSource!): ID
  addClaimNote(id: ID!, note: ClaimNoteInput!): Claim
  createClaimPayment(id: ID!, payment: ClaimPaymentInput!): Claim
  setClaimType(id: ID!, type: ClaimTypes!): Claim
  setClaimInformation(id: ID!, information: ClaimInformationInput!): Claim
  updateReserve(id: ID!, amount: MonetaryAmount!): Claim
  setCoveringEmployee(id: ID!, coveringEmployee: Boolean!): Claim
  createTicket(ticket: TicketInput): ID
  changeTicketDescription(ticketId: ID!, newDescription: String): ID
  assignTicketToTeamMember(ticketId: ID!, teamMemberId: ID!): ID
  changeTicketStatus(ticketId: ID!, newStatus: TicketStatus): ID
  changeTicketReminder(ticketId: ID!, newReminder: RemindNotification): ID
  changeTicketPriority(ticketId: ID!, newPriority: Float): ID
  whitelistMember(memberId: ID!): Boolean
  markClaimFileAsDeleted(claimId: ID!, claimFileId: ID!): Boolean
  backfillSubscriptions(memberId: ID!): Member!
  setClaimFileCategory(claimId: ID!, claimFileId: ID!, category: String): String
  activateQuote(
    id: ID!,
    activationDate: LocalDate!,
    terminationDate: LocalDate
  ): Quote!

  addAgreementFromQuote(
    id: ID!,
    contractId: ID!,
    activeFrom: LocalDate,
    activeTo: LocalDate,
    previousAgreementActiveTo: LocalDate
  ): Quote!

  # Creates a quote from a product and returns the quote id
  createQuoteFromProduct(
    memberId: ID!
    quoteData: QuoteFromProductInput!
  ): Quote!
  createQuoteFromAgreement(
    agreementId: ID!
    memberId: ID!
  ): Quote!
  updateQuote(
    quoteId: ID!
    quoteData: QuoteInput!
    bypassUnderwritingGuidelines: Boolean
  ): Quote!
  markSwitchableSwitcherEmailAsReminded(id: ID!): Boolean!
  terminateContract(contractId: ID!, request: TerminateContractInput): Contract!
  activatePendingAgreement(contractId: ID!, request: ActivatePendingAgreementInput): Contract!
  changeTerminationDate(contractId: ID!, request: ChangeTerminationDateInput): Contract!
  revertTermination(contractId: ID!): Contract!
  createNorwegianGripenPriceEngine(request: CreateNorwegianGripenInput): Boolean!
  addNorwegianPostalCodes(postalCodesString: String): Boolean!
  changeToDate(agreementId: ID!, request: ChangeToDateInput): ID!
  changeFromDate(agreementId: ID!, request: ChangeFromDateInput): ID!
  regenerateCertificate(agreementId: ID!): ID!
  sendMessage(input: SendMessageInput!): SendMessageResponse!
  markQuestionAsResolved(memberId: ID!): Boolean!
  answerQuestion(memberId: ID!, answer: String!): Boolean!
  createQuoteForNewContract(
    memberId: ID!,
    quoteInput: QuoteInput!,
    bypassUnderwritingGuidelines: Boolean!
  ): Quote!
  signQuoteForNewContract(
    quoteId: ID!,
    activationDate: LocalDate
  ): Quote!
  upsertItemCompany(request: UpsertItemCompanyInput): ID!
  upsertItemType(request: UpsertItemTypeInput): ID!
  upsertItemBrand(request: UpsertItemBrandInput): ID!
  upsertItemModel(request: UpsertItemModelInput): ID!
  upsertClaimItem(request: UpsertClaimItemInput): ID!
  deleteClaimItem(claimItemId: ID!): ID
  insertItemCategories(request: InsertItemCategoriesInput): [Boolean!]!
  insertValuationRules(request: InsertValuationRulesInput): [Boolean!]!
  upsertValuationRule(request: UpsertValuationRuleInput): ID!
  assignCampaignToPartnerPercentageDiscount(
    request: AssignVoucherPercentageDiscount
  ): Boolean!
  setContractForClaim(
    request: SetContractForClaim!
  ): Boolean!
  manualRedeemCampaign(memberId: ID!, request: ManualRedeemCampaignInput!): Boolean!
  manualUnRedeemCampaign(memberId: ID!, request: ManualUnRedeemCampaignInput!): Boolean!
  manualRedeemEnableReferralsCampaign(memberId: ID!, market: Market!): Boolean!
}

type ClaimItem {
  id: ID!
  itemFamily: ItemFamily!
  itemType: ItemType!
  itemBrand: ItemBrand
  itemModel: ItemModel
  itemCompany: ItemCompany
  dateOfPurchase: LocalDate
  purchasePrice: MonetaryAmountV2
  valuation: MonetaryAmountV2
  note: String
}

input InsertItemCategoriesInput {
  itemCategoriesString: String!
}

input InsertValuationRulesInput {
  valuationRulesString: String!
}

input GetValuationInput {
  purchasePrice: MonetaryAmount!
  itemFamilyId: String!
  itemTypeId: ID
  typeOfContract: TypeOfContract!
  purchaseDate: LocalDate!
  baseDate: LocalDate
}

type ClaimItemValuation {
  depreciatedValue: MonetaryAmountV2
  valuationRule: ValuationRule
}

type ValuationRule {
  valuationName: String!
  itemFamily: String!
  itemTypeId: ID
  ageLimit: Float!
  valuationTable: String!
  valuationType: String!
  depreciation: Int
}

type CanValuateClaimItem
{
  canValuate: Boolean!
  typeOfContract: TypeOfContract
  itemFamily: String
  itemTypeId: ID
}

input UpsertClaimItemInput {
  id: ID
  claimId: ID!
  itemFamilyId: ID!
  itemTypeId: ID!
  itemBrandId: ID
  itemModelId: ID
  dateOfPurchase: LocalDate
  purchasePrice: MonetaryAmount
  automaticValuation: MonetaryAmount
  customValuation: MonetaryAmount
  note: String
}

input UpsertItemCompanyInput {
  id: ID
  name: String!
}

input UpsertItemTypeInput {
  id: ID
  name: String!
  itemFamilyId: ID!
}

input UpsertItemBrandInput {
  id: ID
  name: String!
  itemTypeId: ID!
  itemCompanyId: ID!
}

input UpsertItemModelInput {
  id: ID
  name: String!
  itemBrandId: ID!
}

input UpsertValuationRuleInput {
  id: ID
  name: String!
  ageLimit: Float!
  typeOfContract: TypeOfContract!
  itemFamilyId: String!
  itemTypeId: String
  valuationType: String!
  depreciation: Float
}

type Contract {
  id: ID!
  holderMemberId: ID!
  holderFirstName: String
  holderLastName: String
  switchedFrom: String
  masterInception: LocalDate
  status: ContractStatus!
  typeOfContract: TypeOfContract!
  isTerminated: Boolean!
  terminationDate: LocalDate
  currentAgreementId: ID!
  hasPendingAgreement: Boolean!
  agreements: [Agreement!]!
  hasQueuedRenewal: Boolean!
  renewal: Renewal
  preferredCurrency: String!
  market: Market!
  signSource: SignSource
  contractTypeName: String!
  createdAt: Instant!
}

enum TypeOfContract {
  SE_HOUSE
  SE_APARTMENT_BRF
  SE_APARTMENT_RENT
  SE_APARTMENT_STUDENT_BRF
  SE_APARTMENT_STUDENT_RENT
  NO_HOME_CONTENT_OWN
  NO_HOME_CONTENT_RENT
  NO_HOME_CONTENT_YOUTH_OWN
  NO_HOME_CONTENT_YOUTH_RENT
  NO_TRAVEL
  NO_TRAVEL_YOUTH
}

enum ContractStatus {
  PENDING
  ACTIVE_IN_FUTURE
  ACTIVE_IN_FUTURE_AND_TERMINATED_IN_FUTURE
  ACTIVE
  TERMINATED_TODAY
  TERMINATED_IN_FUTURE
  TERMINATED
}

union Agreement =
  SwedishApartment
  | SwedishHouse
  | NorwegianHomeContent
  | NorwegianTravel

interface AgreementCore {
  id: ID!
  fromDate: LocalDate
  toDate: LocalDate
  premium: MonetaryAmountV2!
  certificateUrl: String
  status: AgreementStatus!
}

type SwedishApartment implements AgreementCore {
  id: ID!
  fromDate: LocalDate
  toDate: LocalDate
  premium: MonetaryAmountV2!
  certificateUrl: String
  status: AgreementStatus!
  lineOfBusiness: SwedishApartmentLineOfBusiness!
  address: Address!
  numberCoInsured: Int!
  squareMeters: Int!
}

enum SwedishApartmentLineOfBusiness {
  RENT
  BRF
  STUDENT_RENT
  STUDENT_BRF
}

type SwedishHouse implements AgreementCore {
  id: ID!
  fromDate: LocalDate
  toDate: LocalDate
  premium: MonetaryAmountV2!
  certificateUrl: String
  status: AgreementStatus!
  address: Address!
  numberCoInsured: Int!
  squareMeters: Int!
  ancillaryArea: Int!
  yearOfConstruction: Int!
  numberOfBathrooms: Int!
  extraBuildings: [ExtraBuilding!]!
  isSubleted: Boolean!
}

type NorwegianHomeContent implements AgreementCore {
  id: ID!
  fromDate: LocalDate
  toDate: LocalDate
  premium: MonetaryAmountV2!
  certificateUrl: String
  status: AgreementStatus!
  lineOfBusiness: NorwegianHomeContentLineOfBusiness!
  address: Address!
  numberCoInsured: Int!
  squareMeters: Int!
}

enum NorwegianHomeContentLineOfBusiness {
  RENT
  OWN
  YOUTH_RENT
  YOUTH_OWN
}

type NorwegianTravel implements AgreementCore {
  id: ID!
  fromDate: LocalDate
  toDate: LocalDate
  premium: MonetaryAmountV2!
  certificateUrl: String
  status: AgreementStatus!
  lineOfBusiness: NorwegianTravelLineOfBusiness!
  numberCoInsured: Int!
}

enum NorwegianTravelLineOfBusiness {
  REGULAR
  YOUTH
}

enum AgreementStatus {
  PENDING
  ACTIVE_IN_FUTURE
  ACTIVE
  ACTIVE_IN_PAST
  TERMINATED
}

type Address {
  street: String!
  postalCode: String!
  city: String
}

enum SignSource {
  RAPIO
  WEBONBOARDING
  WEB
  APP
  IOS
  ANDROID
  HOPE
}

type Renewal {
  renewalDate: LocalDate!
  draftCertificateUrl: String
  draftOfAgreementId: ID
}

input SetContractForClaim {
  claimId: String!
  memberId: String!
  contractId: String!
}

input TerminateContractInput {
  terminationDate: LocalDate!
  terminationReason: TerminationReason!
  comment: String
}

input ChangeTerminationDateInput {
  newTerminationDate: LocalDate!
}

input ActivatePendingAgreementInput {
  pendingAgreementId: ID!
  fromDate: LocalDate!
}

enum TerminationReason {
  NO_FEEDBACK
  DISSATISFIED_WITH_SERVICE
  DISSATISFIED_WITH_APP
  DISSATISFIED_WITH_HEDVIG
  DISSATISFIED_WITH_OTHER
  ALREADY_HAVE_INSURANCE
  COVERED_BY_PARTNERS_INSURANCE
  PARTNER_ALREADY_HAS_HEDVIG_INSURANCE
  GOT_OFFER_FROM_JOB_OR_UNION_OR_SIMILAR
  WANT_TO_KEEP_OLD_INSURANCE
  STUCK_WITH_OLD_INSURANCE
  DONT_NEED_INSURANCE
  WANTED_OTHER_TYPE_OF_INSURANCE
  REGRET_BY_RIGHT_TO_WITHRAW
  MOVED
  MOVED_ABROAD
  MOVED_IN_WITH_PARENTS
  PRICE
  MISSED_PAYMENTS
  MISSED_PAYMENTS_BAD_RISK
  PAYMENT_ISSUES
  DISCOUNT_PERIOD_OVER
  CONFIRMED_FRAUD
  SUSPECTED_FRAUD
  OTHER
  UNKNOWN
}

input ChangeToDateInput {
  newToDate: LocalDate!
}

input ChangeFromDateInput {
  newFromDate: LocalDate!
}

union ItemCategory = ItemFamily | ItemType | ItemBrand | ItemModel | ItemCompany

interface ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
}

input AssignVoucherPercentageDiscount {
  partnerId: String!
  numberOfMonths: Int!
  percentageDiscount: Float!
  code: String!
  validFrom: Instant
  validUntil: Instant
}

type CampaignOwnerPartner {
  partnerId: String!
}

enum IncentiveType {
  COST_DEDUCTION
  FREE_MONTHS
  NO_DISCOUNT
  MONTHLY_PERCENTAGE_DISCOUNT_FIXED_PERIOD
  INDEFINITE_PERCENTAGE_DISCOUNT
}

type VoucherCampaign {
  id: ID!
  campaignCode: String!
  partnerId: String!
  partnerName: String!
  validFrom: Instant
  validTo: Instant
  incentive: Incentive
}

type MonthlyPercentageDiscountFixedPeriod {
  numberOfMonths: Int,
  percentage: Float
}

type FreeMonths {
  numberOfMonths: Int
}

type CostDeduction {
  amount: MonetaryAmount
}

type NoDiscount {
  _: Boolean
}

type IndefinitePercentageDiscount {
  percentageDiscount: Float
}

union Incentive = MonthlyPercentageDiscountFixedPeriod | FreeMonths | CostDeduction | NoDiscount | IndefinitePercentageDiscount

type ItemFamily implements ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
}

type ItemType implements ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
}

type ItemBrand implements ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
  companyName: String!
}

type ItemModel implements ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
}

type ItemCompany implements ItemCategoryCore {
  id: ID!
  nextKind: ItemCategoryKind
  displayName: String!
  searchTerms: String!
}

enum ItemCategoryKind {
  FAMILY
  TYPE
  BRAND
  MODEL
  COMPANY
}

type FileUpload {
  fileUploadUrl: URL
  timestamp: Instant
  mimeType: String
  memberId: ID
}

type ClaimFileUpload {
  claimFileId: ID
  fileUploadUrl: URL
  uploadedAt: Instant
  claimId: ID
  category: String
  contentType: String
}

type PaymentDefault {
  year: Int
  week: Int
  paymentDefaultType: String
  paymentDefaultTypeText: String
  amount: MonetaryAmount
  caseId: String
  claimant: String
}

type Debt {
  paymentDefaults: [PaymentDefault]
  debtDate: LocalDate
  totalAmountPublicDebt: MonetaryAmount
  numberPublicDebts: Int
  totalAmountPrivateDebt: MonetaryAmount
  numberPrivateDebts: Int
  totalAmountDebt: MonetaryAmount
  checkedAt: Instant
  fromDateTime: LocalDateTime
}

type Person {
  debtFlag: Flag
  debt: Debt
  whitelisted: Whitelisted
  status: PersonStatus
}

type PersonStatus {
  flag: Flag
  whitelisted: Boolean
}

type Whitelisted {
  whitelistedAt: Instant
  whitelistedBy: String
}

enum Flag {
  GREEN
  AMBER
  RED
}

input ClaimInformationInput {
  location: String
  date: LocalDate
  item: String
  policeReport: String
  receipt: String
  ticket: String
}

type MonthlySubscription {
  amount: MonetaryAmount
  member: Member
}

type Member {
  memberId: ID!
  email: String
  phoneNumber: String
  firstName: String
  lastName: String
  personalNumber: String
  birthDate: LocalDate
  gender: Gender
  fraudulentStatus: String
  fraudulentStatusDescription: String
  createdOn: Instant
  signedOn: Instant
  transactions: [Transaction]
  directDebitStatus: DirectDebitStatus
  monthlySubscription(month: YearMonth!): MonthlySubscription
  sanctionStatus: SanctionStatus
  account: Account
  fileUploads: [FileUpload!]!
  person: Person
  numberFailedCharges: NumberFailedCharges
  totalNumberOfClaims: Int!
  quotes: [Quote!]!
  contracts: [Contract!]!
  contractMarketInfo: ContractMarketInfo
  pickedLocale: PickedLocale
  referralInformation: ReferralInformation
}

type ReferralInformation {
  eligible: Boolean!
  campaign: ReferralCampaign!
  referredBy: MemberReferral
  hasReferred: [MemberReferral!]!
  redeemedCampaigns: [RedeemedCampaign!]!
}

type RedeemedCampaign {
  code: String!
  type: String!
  incentive: Incentive!
  redemptionState: RedemptionState!
}

type RedemptionState {
  redeemedAt: Instant!
  activatedAt: Instant
  activeTo: Instant
  terminatedAt: Instant
  unRedeemedAt: Instant
}

type ReferralCampaign {
  code: String!
  incentive: Incentive
}

type MemberReferral {
  memberId: String!
  name: String
  status: String!
  incentive: Incentive!
}

input ManualRedeemCampaignInput {
  campaignCode: String!
  activationDate: LocalDate
}

input ManualUnRedeemCampaignInput {
  campaignCode: String!
}

type ContractMarketInfo {
  market: Market!
  preferredCurrency: String!
}

enum Market {
  SWEDEN
  NORWAY
}

enum PickedLocale {
  sv_SE
  en_SE
  nb_NO
  en_NO
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

interface IQuoteData {
  id: ID!
  householdSize: Int
}

type Quote {
  id: ID!
  createdAt: Instant
  price: Float
  productType: QuoteProductType
  state: QuoteState
  initiatedFrom: String
  attributedTo: String
  currentInsurer: String
  startDate: String
  validity: Int
  memberId: ID
  breachedUnderwritingGuidelines: [String!]
  isComplete: Boolean
  data: QuoteData
  signedProductId: ID
  originatingProductId: ID
  isReadyToSign: Boolean
}

enum QuoteProductType {
  APARTMENT,
  HOUSE,
  OBJECT,
  HOME_CONTENT,
  TRAVEL
}
enum QuoteState {
  INCOMPLETE
  QUOTED
  SIGNED
  EXPIRED
}

union QuoteData = ApartmentQuoteData | HouseQuoteData | NorwegianHomeContentQuoteData | NorwegianTravelQuoteData

type ApartmentQuoteData implements IQuoteData {
  id: ID!
  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int
  subType: ApartmentSubType
}

enum ApartmentSubType {
  BRF,
  RENT,
  STUDENT_BRF,
  STUDENT_RENT
}

type HouseQuoteData implements IQuoteData {
  id: ID!
  ssn: String
  firstName: String
  lastName: String
  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  ancillaryArea: Int
  yearOfConstruction: Int
  numberOfBathrooms: Int
  extraBuildings: [ExtraBuilding!]!
  isSubleted: Boolean
}

input CampaignFilter {
  code: String
  partnerId: String
  activeFrom: LocalDate
  activeTo: LocalDate
}

type ExtraBuilding {
  id: ID
  type: ExtraBuildingType!
  area: Int!
  hasWaterConnected: Boolean!
  displayName: String
}

enum ExtraBuildingType {
  GARAGE
  CARPORT
  SHED
  STOREHOUSE
  FRIGGEBOD
  ATTEFALL
  OUTHOUSE
  GUESTHOUSE
  GAZEBO
  GREENHOUSE
  SAUNA
  BARN
  BOATHOUSE
  OTHER
}

type NorwegianHomeContentQuoteData implements IQuoteData{
  id: ID!
  ssn:  String
  firstName: String
  lastName: String

  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int
  subType: NorwegianHomeContentLineOfBusiness
}

type NorwegianTravelQuoteData implements IQuoteData{
  id: ID!
  ssn:  String
  firstName: String
  lastName: String
  householdSize: Int
  subType: NorwegianTravelLineOfBusiness
}

input QuoteInput {
  productType: QuoteProductType
  currentInsurer: String
  apartmentData: ApartmentQuoteInput
  houseData: HouseQuoteInput
  norwegianHomeContentData: NorwegianHomeContentQuoteInput
  norwegianTravelData: NorwegianTravelQuoteInput
  originatingProductId: ID
}

input ApartmentQuoteInput {
  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  subType: ApartmentSubType
}

input HouseQuoteInput {
  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  ancillaryArea: Int
  yearOfConstruction: Int
  numberOfBathrooms: Int
  extraBuildings: [ExtraBuildingInput!]
  isSubleted: Boolean
}

input NorwegianHomeContentQuoteInput {
  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  subType: NorwegianHomeContentLineOfBusiness
}


input NorwegianTravelQuoteInput {
  householdSize: Int
  subType: NorwegianTravelLineOfBusiness
}

input QuoteFromProductInput {
  incompleteHouseQuoteData: HouseQuoteDataInput
  incompleteApartmentQuoteData: ApartmentQuoteDataInput
  norwegianHomeContentQuoteData: NorwegianHomeContentQuoteDataInput
  norwegianTravelQuoteData: NorwegianTravelQuoteDataInput
  originatingProductId: ID
  currentInsurer: String
}

input ApartmentQuoteDataInput {
  ssn: String
  firstName: String
  lastName: String

  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  subType: ApartmentSubType
}

input HouseQuoteDataInput {
  ssn: String
  firstName: String
  lastName: String

  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  ancillaryArea: Int
  yearOfConstruction: Int
  numberOfBathrooms: Int
  extraBuildings: [ExtraBuildingInput!]!
  isSubleted: Boolean
}

input ExtraBuildingInput {
  type: String!
  area: Int!
  hasWaterConnected: Boolean!
  displayName: String
}

input NorwegianHomeContentQuoteDataInput {
  ssn:  String
  firstName: String
  lastName: String

  street: String
  city: String
  zipCode: String
  householdSize: Int
  livingSpace: Int

  subType: NorwegianHomeContentLineOfBusiness
}

input NorwegianTravelQuoteDataInput {
  ssn:  String
  firstName: String
  lastName: String

  householdSize: Int
  subType: NorwegianTravelLineOfBusiness
}

type PaymentCompletionResponse {
  url: String!
}

type Transaction {
  id: ID
  amount: MonetaryAmountV2
  timestamp: Instant
  type: String
  status: String
}

type DirectDebitStatus {
  activated: Boolean
}

enum SanctionStatus {
  Undetermined
  NoHit
  PartialHit
  FullHit
}

type NumberFailedCharges {
  numberFailedCharges: Int!
  lastFailedChargeAt: Instant
}

type Account {
  id: ID!
  currentBalance: MonetaryAmountV2!
  totalBalance: MonetaryAmountV2!
  chargeEstimation: AccountChargeEstimation!
  entries: [AccountEntry!]!
}

type AccountChargeEstimation {
  subscription: MonetaryAmountV2!
  discount: MonetaryAmountV2!
  charge: MonetaryAmountV2!
  discountCodes: [String!]!
}

type SchedulerState {
  id: ID!
  member: Member
  status: ChargeStatus!
  changedBy: String!
  changedAt: Instant!
  amount: MonetaryAmount
  transactionId: ID
}

input MemberChargeApproval {
  memberId: ID!
  amount: MonetaryAmount!
}

input AccountEntryInput {
  type: AccountEntryType!
  amount: MonetaryAmount!
  fromDate: LocalDate!
  reference: String!
  source: String!
  title: String
  comment: String
}

type AccountEntry {
  id: ID!
  type: AccountEntryType!
  amount: MonetaryAmountV2!
  fromDate: LocalDate!
  reference: String!
  source: String!
  title: String
  comment: String
  failedAt: Instant
  chargedAt: Instant
}

enum AccountEntryType {
  CORRECTION
  SUBSCRIPTION
  CAMPAIGN
  PAYOUT
  CHARGE
  REFERRAL_DISCOUNT
  FREE_MONTH_DISCOUNT
  PERCENTAGE_MONTH_DISCOUNT
  BUNDLE_DISCOUNT_COST_DEDUCTION
  BUNDLE_DISCOUNT_PERCENTAGE_DEDUCTION
  LOSS
}

enum ClaimSource {
  APP
  EMAIL
  INTERCOM
  PHONE
  CHAT
}

type Claim {
  id: ID
  member: Member
  recordingUrl: String
  state: ClaimState
  type: ClaimType
  reserves: MonetaryAmount
  registrationDate: Instant
  notes: [ClaimNote]
  transcriptions: [ClaimTranscription]
  payments: [ClaimPayment]
  events: [ClaimEvent]
  coveringEmployee: Boolean!
  claimFiles: [ClaimFileUpload!]!
  contract: Contract
}

type ClaimNote {
  text: String
  date: LocalDateTime
}

type ClaimTranscription {
  text: String!
  confidenceScore: Float!
  languageCode: String!
}

enum ClaimTypes {
  TheftClaim
  AccidentalDamageClaim
  AssaultClaim
  WaterDamageClaim
  TravelAccidentClaim
  LuggageDelayClaim
  NotCoveredClaim
  FireDamageClaim
  ApplianceClaim
  ConfirmedFraudClaim
  LiabilityClaim
  LegalProtectionClaim
  WaterDamageBathroomClaim
  WaterDamageKitchenClaim
  BurglaryClaim
  FloodingClaim
  EarthquakeClaim
  InstallationsClaim
  SnowPressureClaim
  StormDamageClaim
  VerminAndPestsClaim
  TestClaim
}
union ClaimType =
  TheftClaim
  | AccidentalDamageClaim
  | AssaultClaim
  | WaterDamageClaim
  | TravelAccidentClaim
  | LuggageDelayClaim
  | NotCoveredClaim
  | FireDamageClaim
  | ConfirmedFraudClaim
  | LiabilityClaim
  | ApplianceClaim
  | LegalProtectionClaim
  | WaterDamageBathroomClaim
  | WaterDamageKitchenClaim
  | BurglaryClaim
  | FloodingClaim
  | EarthquakeClaim
  | InstallationsClaim
  | SnowPressureClaim
  | StormDamageClaim
  | VerminAndPestsClaim
  | TestClaim

type TheftClaim {
  location: String
  date: LocalDate
  item: String
  policeReport: String
  receipt: String
}

type AccidentalDamageClaim {
  location: String
  date: LocalDate
  item: String
  policeReport: String
  receipt: String
}

type AssaultClaim {
  location: String
  date: LocalDate
  policeReport: String
}

type WaterDamageClaim {
  date: LocalDate
}

type TravelAccidentClaim {
  location: String
  date: LocalDate
  policeReport: String
  receipt: String
}

type LuggageDelayClaim {
  location: String
  date: LocalDate
  ticket: String
}

type ConfirmedFraudClaim {
  date: LocalDate
}

type LiabilityClaim {
  date: LocalDate
  location: String
}

type FireDamageClaim {
  location: String
  date: LocalDate
}

type ApplianceClaim {
  location: String
  date: LocalDate
  item: String
}

type LegalProtectionClaim {
  date: LocalDate
}

type WaterDamageBathroomClaim {
  date: LocalDate
}

type WaterDamageKitchenClaim {
  date: LocalDate
}

type BurglaryClaim {
  location: String
  date: LocalDate
  item: String
  policeReport: String
  receipt: String
}

type FloodingClaim {
  date: LocalDate
}

type EarthquakeClaim {
  date: LocalDate
}

type InstallationsClaim {
  date: LocalDate
  item: String
  location: String
}

type SnowPressureClaim {
  date: LocalDate
}

type StormDamageClaim {
  date: LocalDate
}

type VerminAndPestsClaim {
  date: LocalDate
}

type NotCoveredClaim {
  date: LocalDate
}

type TestClaim {
  date: LocalDate
}

type ClaimPayment {
  id: String
  amount: MonetaryAmount
  deductible: MonetaryAmount
  note: String
  type: ClaimPaymentType
  timestamp: Instant
  exGratia: Boolean
  transaction: Transaction
  status: ClaimPaymentStatus
}

enum ClaimPaymentStatus {
  PREPARED
  INITIATED
  SANCTION_LIST_HIT
  COMPLETED
  FAILED
}

input ClaimPaymentInput {
  amount: MonetaryAmount!
  deductible: MonetaryAmount!
  note: String!
  type: ClaimPaymentType!
  exGratia: Boolean!
  sanctionListSkipped: Boolean!
}

input ClaimNoteInput {
  text: String!
}

type ClaimEvent {
  text: String
  date: Instant
}

type SwitchableSwitcherEmail {
  id: ID!
  member: Member!
  switcherCompany: String!
  queuedAt: Instant!
  sentAt: Instant
  remindedAt: Instant
}

enum ClaimState {
  OPEN
  CLOSED
  REOPENED
}

enum ClaimPaymentType {
  Manual
  Automatic
}

enum ChargeStatus {
  INITIATED
  WAITING_FOR_SUBSCRIPTION
  SCHEDULING_SUBSCRIPTION
  SCHEDULE_SUBSCRIPTION_FAILED
  SUBSCRIPTION_SCHEDULED_AND_WAITING_FOR_APPROVAL
  APPROVED_FOR_CHARGE
  SCHEDULING_CHARGE
  CHARGE_REQUESTING
  CHARGE_REQUEST_FAILED
  CHARGE_INITIATED
  CHARGE_FAILED
  CHARGE_COMPLETED
}

type QuestionGroup {
  id: ID!
  memberId: ID!
  questions: [Question!]!
  member: Member
}

type Question {
  id: ID!
  timestamp: Instant!
  messageJsonString: String!
}

input TicketInput {
  assignedTo: String
  priority: Float
  type: TicketType
  remindNotificationDate: LocalDate
  remindNotificationTime: LocalTime
  remindMessage: String
  description: String
  status: TicketStatus
  referenceId: String
  memberId: String
}

type Ticket {
  id: ID
  assignedTo: String
  createdAt: Instant
  createdBy: String
  memberId: String
  referenceId: String
  priority: Float
  type: TicketType
  remindNotificationDate: LocalDate
  remindNotificationTime: LocalTime
  remindMessage: String
  description: String
  status: TicketStatus
}

type TicketHistory {
  id: ID
  createdAt: Instant
  createdBy: String
  type: TicketType
  revisions: [TicketRevision]
}

type TicketRevision {
  assignedTo: String
  manualPriority: Float
  remindDate: LocalDate
  remindTime: LocalTime
  remindMessage: String
  status: TicketStatus
  changedAt: Instant
  changeType: TicketChangeType
  changedBy: String
  description: String
}

input RemindNotification {
  date: LocalDate
  time: LocalTime
  message: String
}

enum TicketChangeType {
  TICKET_CREATED
  CHANGED_REMINDER
  CHANGED_ASSIGNED_TO
  CHANGED_DESCRIPTION
  CHANGED_STATUS
  CHANGED_PRIORITY
}

enum TicketStatus {
  WAITING
  WORKING_ON
  ON_HOLD
  RESOLVED
}

enum TicketType {
  REMIND
  MESSAGE
  CLAIM
  CALL_ME
  OTHER
}

input CreateNorwegianGripenInput {
  baseFactorString: String
  factors: [NorwegianGripenFactorInput!]!
}

input NorwegianGripenFactorInput {
  factorType: NorwegianGripenFactorType!
  factorString: String!
}

enum NorwegianGripenFactorType {
  AGE
  CENTRALITY_GROUP
  ECONOMY_OF_MUNICIPALITY
  NUMBER_OF_PEOPLE
  SQUARE_METERS
  HOUSEHOLD_TYPE
  DEDUCTIBLE
}

type ChatMessage {
  globalId: ID!
  author: String,
  fromId: String!,
  timestamp: Instant,
  messageBodyJsonString: String!
}

union SendMessageResponse = SendMessageSuccessful | SendMessageFailed

type SendMessageSuccessful {
  memberId: String!
}

type SendMessageFailed {
  memberId: String!
  errorCode: Int!
  errorMessage: String!
}

input SendMessageInput {
  memberId: ID!
  message: String!
  forceSendMessage: Boolean!
}

type MonetaryAmountV2 {
  amount: String!,
  currency: String!
}

# A String-representation of `java.time.YearMonth`, ex: `"2018-06"`
scalar YearMonth
# An object-representation of `javax.money.MonetaryAmount`, ex: `{"amount": 100  "currency": "SEK"}`
scalar MonetaryAmount
# A String-representation of `java.time.ZonedDateTime`, ex: `"2018-09-21T14:17:46.536405+02:00[Europe/Stockholm]"`
scalar ZonedDateTime
# A String-representation of `java.time.LocalDate`, ex:  `"2018-09-26"`
scalar LocalDate
# A String-representation of `java.time.LocalTime`
scalar LocalTime
# A String-representation of `java.time.LocalDateTIme`, ex: `"2018-06-11T20:08:30.123456"`
scalar LocalDateTime
# A String-representation of `java.time.Instant`, ex: `"2018-06-11T20:08:30.123456"`
scalar Instant
# A String-representation of `java.net.URL`, ex: "https://www.google.com/"
scalar URL
